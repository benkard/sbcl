(in-package "SB!EVAL2")

#+sbcl
(declaim (optimize (debug 0) (space 0) (speed 3) (safety 0) (compilation-speed 0)
                   (sb!c::store-closure-debug-pointer 0)))

(deftype eval-closure () `(function (environment) *))

(defstruct (debug-record (:constructor
                             make-debug-record
                             (context &optional (lambda-list :none) function-name))
                         #-(or)   ;for debugging purposes
                         (:print-function (lambda (object stream foo)
                                            (declare (ignore object foo))
                                            (format stream "#<DEBUG-RECORD>"))))
  (context nil :type context)
  (lambda-list nil :type (or list (member :none)))
  (function-name nil))

#+(or)
(deftype environment ()
  `(simple-vector 3))

(declaim (inline %make-environment
                 environment-debug-record
                 environment-parent
                 environment-data))
(defstruct (environment (:constructor
                            %make-environment
                            (debug-record parent data))
                        ;;(:type vector)
                        )
  (debug-record nil :type (or null debug-record))
  (parent nil :type (or null environment))
  (data nil :type simple-vector))

(declaim (inline make-null-environment))
(defun make-null-environment ()
  (make-environment (make-debug-record (make-null-context)) nil 0))

(declaim (inline make-environment))
(defun make-environment (debug-record
                         parent
                         &optional (size 0)
                         &aux (data
                               (if (zerop (the fixnum size))
                                   #()
                                   (make-array (list size)))))
  (%make-environment debug-record parent data))

(defstruct lexical
  (name    nil :type (or symbol list))
  (offset  nil :type fixnum)
  (nesting nil :type fixnum))

(defun make-env-lexical (name offset &optional (nesting -1))
  (make-lexical :name name :offset offset :nesting nesting))

(defun lexical-with-nesting (lexical nesting)
  (make-lexical :name (lexical-name lexical) :offset (lexical-offset lexical) :nesting nesting))


(defstruct (context (:constructor make-context (&optional parent)))
  parent
  (env-hop nil :type boolean)
  (block-tags nil :type list)
  (go-tags nil :type list)
  (symbol-macros nil :type list)
  (macros nil :type list)
  (lexicals nil :type list)
  (specials nil :type list)
  (%evaluation-environment nil :type (or null environment))
  (%evaluation-context nil :type (or null context)))
(defun make-null-context ()
  (make-context nil))
(defun context-evaluation-environment (context)
  (let ((parent (context-parent context)))
    (or (context-%evaluation-environment context)
        (and parent (context-evaluation-environment parent))
        (make-null-environment))))
(defun context-add-evaluation-bindings (context bindings)
  (let* ((new-context (make-context context))
         (evlctx (context-evaluation-context context))
         (evlenv (make-environment nil
                                   (context-evaluation-environment context)
                                   (length bindings))))
    (loop for value in (mapcar #'cdr bindings)
          for i from 0
          do (setf (environment-value evlenv 0 i) value))
    (setf (context-%evaluation-environment new-context)
          evlenv)
    (setf (context-%evaluation-context new-context)
          (context-add-env-lexicals evlctx (mapcar #'car bindings)))
    new-context))
(defun context-evaluation-context (context)
  (let ((parent (context-parent context)))
    (or (context-%evaluation-context context)
        (and parent (context-evaluation-context parent))
        (make-null-context))))
(defun context-add-block-tag (context block tag)
  (let ((new-context (make-context context)))
    (push (cons block tag) (context-block-tags new-context))
    new-context))
(defun context-block-tag (context block)
  (let ((parent (context-parent context)))
    (or (cdr (assoc (the symbol block) (context-block-tags context)))
        (and parent (context-block-tag parent block)))))
(defun context-add-go-tags (context new-go-tags catch-tag)
  (let ((new-context (make-context context)))
    (dolist (new-go-tag new-go-tags)
      (push (cons new-go-tag catch-tag)
            (context-go-tags new-context)))
    new-context))
(defun context-collect (context f)
  (let ((parent (context-parent context)))
    (append (funcall f context) (and parent (context-collect parent f)))))
(defun context-find-go-tag (context go-tag)
  (let ((parent (context-parent context)))
    (or (cdr (assoc (the atom go-tag) (context-go-tags context)))
        (and parent (context-find-go-tag parent go-tag)))))
(defun context-find-symbol-macro (context symmac)
  (let ((parent (context-parent context)))
    (and (not (member symmac
                      (context-lexicals context)
                      :test #'equal
                      :key #'lexical-name))
         (not (member symmac (context-specials context) :test #'equal))
         (or (let ((record? (assoc (the symbol symmac) (context-symbol-macros context))))
               (and record? (list (cdr record?))))
             (and parent (context-find-symbol-macro parent symmac))))))
(defun context-find-macro (context mac)
  (let ((parent (context-parent context)))
    (and (not (member `(function ,mac)
                      (context-lexicals context)
                      :test #'equal
                      :key #'lexical-name))
         (or (cdr (assoc (the (or symbol list) mac)
                         (context-macros context)
                         :test #'equal))
             (and parent (context-find-macro parent mac))))))
(defun context-add-symbol-macros (context bindings)
  (let ((new-context (make-context context)))
    (setf (context-symbol-macros new-context)
          (append bindings (context-symbol-macros new-context)))
    new-context))
(defun context-add-macros (context bindings)
  (let ((new-context (make-context context)))
    (setf (context-macros new-context)
          (append bindings (context-macros new-context)))
    new-context))
(defun context-var-symbol-macro-p (context var)
  (and (not (find var (context-specials context) :test #'equal))
       (not (find var (context-lexicals context) :key #'lexical-name :test #'equal))
       (or (find var (context-symbol-macros context) :key #'car :test #'equal)
           (and (context-parent context)
                (context-var-symbol-macro-p (context-parent context) var)))))
(defun context-var-lexical-p (context var)
  (and (not (find var (context-specials context) :test #'equal))
       (not (find var (context-symbol-macros context) :key #'car :test #'equal))
       (or (find var (context-lexicals context) :key #'lexical-name :test #'equal)
           (and (context-parent context)
                (context-var-lexical-p (context-parent context) var)))))
(defun context-var-special-p (context var)
  (and (not (find var (context-lexicals context) :key #'lexical-name :test #'equal))
       (not (find var (context-symbol-macros context) :key #'car :test #'equal))
       (or (find var (context-specials context) :test #'equal)
           (and (context-parent context)
                (context-var-special-p (context-parent context) var)))))
(defun context-add-env-lexicals (context vars)
  ;; open a new variable context
  (let ((new-context (make-context context)))
    (setf (context-env-hop new-context) t)
    (setf (context-lexicals new-context)
          (loop for i fixnum from 0
                for v in vars
                collect (make-env-lexical v i)))
    new-context))
(defun make-lexical-context (context)
  (let ((new-context (make-context context)))
    (setf (context-env-hop new-context) t)
    new-context))
(defun context-add-env-lexical! (context var)
  (push (make-env-lexical var (length (context-lexicals context)))
        (context-lexicals context))
  (values))
(defun context-add-specials (context vars)
  (let ((new-context (make-context context)))
    (setf (context-specials new-context) vars)
    new-context))
(defun context-add-special! (context var)
  (push var (context-specials context))
  (values))
(defun context-add-env-functions (context fs)
  (context-add-env-lexicals context (mapcar (lambda (x) `(function ,x)) fs)))
(defun context-collect-lexicals (context)
  (loop with env-level = 0
        until (null context)
        for records = (context-lexicals context)
        nconc (mapcar #'(lambda (record) (lexical-with-nesting record env-level))
                      records)
        when (context-env-hop context)
          do (incf env-level)
        do (setq context (context-parent context))))
(defun context-find-lexical (context var)
  (find var (context-collect-lexicals context) :key #'lexical-name :test #'equal))
(declaim (ftype (function (context (or symbol list)) *) context-find-function))
(defun context-find-function (context f)
  (context-find-lexical context `(function ,f)))

(declaim (ftype (function (context (or symbol list)) *) local-function-p))
(defun local-function-p (context f)
  (context-find-function context f))

(declaim (inline environment-value))
(defun environment-value (env nesting offset)
  (dotimes (i (the fixnum nesting))
    (setq env (environment-parent env)))
  (svref (environment-data env) offset))

(declaim (inline (setf environment-value)))
(defun (setf environment-value) (val env nesting offset)
  (dotimes (i (the fixnum nesting))
    (setq env (environment-parent env)))
  (setf (svref (environment-data env) offset) val))
